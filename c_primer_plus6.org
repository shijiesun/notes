#+STARTUP: content
#+TITLE: C Primer Plus Notes
#+AUTHOR:      孙士杰
#+DATE:       <2018-05-23 Wed>
#+EMAIL:       sun.shijie5@ztesoft.com


* 显示八进制 十六进制

#+BEGIN_SRC C++
  int x = 100;
  printf("ddec = %d; octal = %#o; hex = %#x\n", x, x, x);
#+END_SRC

* int类型的选择
对于long类型比int类型大的系统，使用long会减慢运算速度，如非必要必要使用long
对于long类型与int类型相同的系统，如果要使用32位的整数，请使用long，便于一直到16位机器时，仍然能够正常运行。
如果确实需要使用64位的整数，请使用long long
除非必要，不用short，short很少用，通常不太需要节省内存空间
对于大常熟，编译器会自动选择类型是int，long int， unsigned long， long long， unsigned long long

** 后缀表示
| l或L                  | long               | 推荐用L |
| ll或LL                | long long          |         |
| 5ull 10LLU 6LLU  9ULL | unsigned long long |         |

** 打印
| %u             | unsigned ing       |
| %ld            | long               |
| %lx            | long 十六进制      |
| %lo            | long 八进制        |
| %h             | short              |
| %hd  %ho       |                    |
| %lu            | unsigned long      |
| %ll %lld  %llu | long long          |
| %zd            | sizeof             |
| %%             | %                  |
| %td            | 指针差值 ptrdiff_t |



#+BEGIN_SRC C++
  /* print2.c-more printf() properties */
  #include <stdio.h>
  int main(void)
  {
      unsigned int un = 3000000000; /* system with 32-bit int */
      short end = 200;              /* and 16-bit short       */
      long big = 65537;
      long long verybig = 12345678908642;

      printf("un = %u and not %d\n", un, un);
      printf("end = %hd and %d\n", end, end);
      printf("big = %ld and not %hd\n", big, big);
      printf("verybig= %lld and not %ld\n", verybig, verybig);

      return 0;
  }

//outpur
un = 3000000000 and not -1294967296  //无符号数使用%d打印，越界会变成负值
end = 200 and 200  //传递参数时会把short转int，int传递参数更高效的
big = 65537 and not 1 //long使用%hd打印会截断，只取后16位
verybig= 12345678908642 and not 12345678908642  //long long 使用%ld打印也会截断，只取后32位
#+END_SRC
*
* 可移植类型
** stdint.h
精确宽度整数类型 int32_t
** inttypes.h
最小宽度类型 int_least8_t
最快最小宽度类型 int_fast8_t
最大的有符号数类型 int_max_t

* 浮点数
可表示很大或很小的数
float   32位  8位用于指数数值和符号  24位用于非指数部分  小数点后可精确到6位有效数字
double  64位
long double 无标准
eg: 2.3F 4.32L

#+BEGIN_SRC C
  #include <stdio.h>
  int main(void)
  {
      float aboat = 32000.0;
      double abet = 2.14e9;
      long double dip = 5.32e-5;

      printf("%f can be written %e\n", aboat, aboat);
      // next line requires C99 or later compliance
      printf("And it's %a in hexadecimal, powers of 2 notation\n", aboat);
      printf("%f can be written %e\n", abet, abet);
      printf("%Lf can be written %Le\n", dip, dip);

      return 0;
  }

  32000.000000 can be written 3.200000e+04
  And it's 0x1.f4p+14 in hexadecimal, powers of 2 notation
  2140000000.000000 can be written 2.140000e+09
  0.000053 can be written 5.320000e-05
#+END_SRC
** overflow
上溢 会变成无穷大的特定值 inf
下溢出  正常的下溢出 会损失尾数部分的精度，直到变成0
NaN
* 复数
...
* 输入输出
** printf
#+BEGIN_SRC C
  char name[40];

  printf("Your name of %zd letters occupies %zd memory cells.\n",
         strlen(name), sizeof name);
  sizeof(int);
  sizeof name;
  //圆括号的很少用时机取决于运算对象是类型还是特定量
#+END_SRC


#+BEGIN_SRC C
  #include <stdio.h>
  #include <limits.h>    // integer limits
  #include <float.h>     // floating-point limits
  int main(void)
  {
      printf("Some number limits for this system:\n");
      printf("Biggest int: %d\n", INT_MAX);
      printf("Smallest long long: %lld\n", LLONG_MIN);
      printf("One byte = %d bits on this system.\n", CHAR_BIT);
      printf("Largest double: %e\n", DBL_MAX);
      printf("Smallest normal float: %e\n", FLT_MIN);
      printf("float precision = %d digits\n", FLT_DIG);
      printf("float epsilon = %e\n", FLT_EPSILON);

      return 0;
  }

#+END_SRC


#+BEGIN_SRC C
  #include <stdio.h>
  #define PAGES 959
  int main(void)
  {
      printf("*%d*\n", PAGES);
      printf("*%2d*\n", PAGES);
      printf("*%10d*\n", PAGES);
      printf("*%-10d*\n", PAGES);

      return 0;
  }

  ,*959*
  ,*959*
  ,*       959*
  ,*959       *
#+END_SRC


#+BEGIN_SRC C
  #include <stdio.h>

  int main(void)
  {
      const double RENT = 3852.99;  // const-style constant

      printf("*%f*\n", RENT);
      printf("*%e*\n", RENT);
      printf("*%4.2f*\n", RENT);
      printf("*%3.1f*\n", RENT);
      printf("*%10.3f*\n", RENT);
      printf("*%10.3E*\n", RENT);
      printf("*%+4.2f*\n", RENT);
      printf("*%010.2f*\n", RENT);

      return 0;
  }

  ,*3852.990000*
  ,*3.852990e+03*
  ,*3852.99*
  ,*3853.0*
  ,*  3852.990*
  ,* 3.853E+03*
  ,*+3852.99*
  ,*0003852.99*

#+END_SRC


#+BEGIN_SRC C
  /* flags.c -- illustrates some formatting flags */
  #include <stdio.h>
  int main(void)
  {
      printf("%x %X %#x\n", 31, 31, 31);
      printf("**%d**% d**% d**\n", 42, 42, -42);
      printf("**%5d**%5.3d**%05d**%05.3d**\n", 6, 6, 6, 6);

      return 0;
  }
#+END_SRC


#+BEGIN_SRC C
  #include <stdio.h>
  #define BLURB "Authentic imitation!"
  int main(void)
  {
      printf("[%2s]\n", BLURB);
      printf("[%24s]\n", BLURB);
      printf("[%24.5s]\n", BLURB);
      printf("[%-24.5s]\n", BLURB);
      return 0;
  }

  [Authentic imitation!]
  [    Authentic imitation!]
  [                   Authe]
  [Authe                   ]

#+END_SRC


#+BEGIN_SRC C
  /* varwid.c -- uses variable-width output field */
  #include <stdio.h>
  int main(void)
  {
      unsigned width, precision;
      int number = 256;
      double weight = 242.5;

      printf("Enter a field width:\n");
      scanf("%d", &width);
      printf("The number is :%*d:\n", width, number);
      printf("Now enter a width and a precision:\n");
      scanf("%d %d", &width, &precision);
      printf("Weight = %*.*f\n", width, precision, weight);
      printf("Done!\n");

      return 0;
  }

#+END_SRC
使用星号表示宽度和精度

** scanf

#+BEGIN_SRC C
  /* skiptwo.c -- skips over first two integers of input */
  #include <stdio.h>
  int main(void)
  {
      int n;

      printf("Please enter three integers:\n");
      scanf("%*d %*d %d", &n);
      printf("The last integer was %d\n", n);

      return 0;
  }

#+END_SRC

星号表示跳过
